{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Next.js 15 Project with TypeScript and Core Dependencies",
        "description": "Initialize the Next.js 15 project with React 19, TypeScript, and install core dependencies including Shadcn/ui, Tailwind CSS, XState, Zustand, and Chart.js",
        "details": "Create new Next.js 15 project using `npx create-next-app@latest pfs-editor --typescript --tailwind --eslint --app`. Install dependencies: `npm install @xstate/react zustand @radix-ui/react-* shadcn-ui chart.js react-chartjs-2 @types/chart.js`. Setup Shadcn/ui with `npx shadcn-ui@latest init`. Configure TypeScript strict mode and ESLint rules. Setup project structure with components/, lib/, types/, and stores/ directories.",
        "testStrategy": "Verify project builds successfully with `npm run build`. Test TypeScript compilation and ESLint passes. Confirm all dependencies are properly installed and importable.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Core Data Models and Types",
        "description": "Define TypeScript interfaces and types for Funscript data structures, video metadata, and application state",
        "details": "Create types/funscript.ts with interfaces: FunscriptObject { version: string, inverted: boolean, range: number, actions: FunscriptAction[], metadata?: any }, FunscriptAction { id: number, at: number, pos: number }, FunscriptMetadata { version: string, range: number, inverted: boolean }. Create types/video.ts for video metadata. Create types/editor.ts for editor state types including selection, zoom, and playback states.",
        "testStrategy": "Write unit tests to validate type definitions. Test JSON parsing with sample Funscript files. Verify TypeScript compilation with strict type checking.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Build Video Upload and File Handling System",
        "description": "Implement project-based workflow with video file handling, funscript management, and browser-specific persistence for development workflow",
        "status": "done",
        "dependencies": [
          2
        ],
        "priority": "high",
        "details": "Create a project-based system where users can create projects with names, upload/select video files, and manage funscript files. Implement browser-specific file persistence: use File System Access API with IndexedDB for Chromium browsers, and traditional file input with session storage for Firefox/Safari. Projects should store video file references and funscript data, allowing users to reopen projects and automatically reload video and funscript content. Support MP4, WebM, OGV formats with file validation.",
        "testStrategy": "Test project creation, saving, and loading across different browsers. Verify video file persistence in Chromium browsers across sessions. Test funscript file handling and project state restoration. Validate graceful degradation for non-Chromium browsers. Test error handling for unsupported formats and missing files.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create project data model and storage",
            "description": "Implement project data structure with video file references, funscript data, and metadata. Create storage layer using localforage for project persistence",
            "status": "done",
            "dependencies": [],
            "details": "Define Project interface with id, name, createdAt, videoFile reference, funscript data, and settings. Implement lib/project-storage.ts with CRUD operations using localforage. Handle browser-specific file reference storage (file handles for Chromium, file metadata for others).",
            "testStrategy": "Test project creation, retrieval, update, and deletion. Verify data persistence across browser sessions."
          },
          {
            "id": 2,
            "title": "Build project management interface",
            "description": "Create components for project creation, listing, and selection with a clean UI",
            "status": "done",
            "dependencies": [],
            "details": "Implement components/ProjectManager.tsx with project list, create new project dialog, and project selection. Add project cards showing name, creation date, and preview. Include delete and rename functionality.\n<info added on 2025-07-20T10:35:01.683Z>\n**Implementation Progress:**\n\n**Completed Components:**\n1. **Database Layer** (`src/lib/db/`):\n   - ✅ `types.ts` - Project data model with video file references and funscript data\n   - ✅ `localStorage.ts` - localStorage provider for project persistence\n   - ✅ `index.ts` - Main database API with CRUD operations\n\n2. **Browser Utilities** (`src/lib/browser-utils.ts`):\n   - ✅ Browser detection (Chromium vs others)\n   - ✅ File System Access API for Chromium browsers\n   - ✅ Fallback file input for non-Chromium browsers\n   - ✅ Video file validation (format, size)\n   - ✅ Blob URL management\n\n3. **Project Hook** (`src/hooks/useProject.ts`):\n   - ✅ Complete project state management\n   - ✅ Video file selection and blob URL handling\n   - ✅ Funscript data management\n   - ✅ Project CRUD operations\n   - ✅ Error handling and loading states\n\n4. **UI Components**:\n   - ✅ `ProjectManager.tsx` - Project listing, creation, deletion\n   - ✅ `ProjectWorkflow.tsx` - Step-by-step workflow UI\n   - ✅ Updated `src/app/page.tsx` to use new workflow\n\n**Current Status:**\n- All core functionality implemented and working\n- TypeScript compilation successful\n- Development server started for testing\n- Ready for user testing and refinement\n\n**Next Steps:**\n- Test the workflow in browser\n- Add funscript file upload functionality\n- Improve error handling and user feedback\n- Add project settings and metadata\n</info added on 2025-07-20T10:35:01.683Z>\n<info added on 2025-07-20T11:59:25.046Z>\n**XState Machine Implementation Complete:**\n\n**Created XState-based Project Workflow:**\n\n1. **Project Machine** (`src/lib/fs_machines/projectMachine.ts`):\n   - ✅ State machine with 4 states: `selectProject`, `selectVideo`, `selectFunscript`, `ready`\n   - ✅ Context management for project data, video blob URLs, errors, and loading states\n   - ✅ Event-driven transitions with proper TypeScript typing\n   - ✅ Actions for updating project context on state transitions\n   - ✅ Service for project saving (currently mocked)\n\n2. **Project Actor Context** (`src/components/fs_components/ProjectActorContext.tsx`):\n   - ✅ XState actor context following same pattern as FsEditActorContext\n   - ✅ `useProjectActorRef` and `useProjectSelector` hooks for state management\n   - ✅ Provider component for React integration\n\n3. **New Workflow Component** (`src/components/ProjectWorkflowXState.tsx`):\n   - ✅ Complete UI for all 4 workflow states\n   - ✅ Project creation dialog with name input\n   - ✅ Project selection from mock data\n   - ✅ Video file selection with browser-specific messaging\n   - ✅ Funscript selection/creation options\n   - ✅ Project summary and save functionality\n   - ✅ Progress indicator showing current step\n   - ✅ Error handling and display\n   - ✅ Navigation between states\n\n4. **Updated Main Page** (`src/app/page.tsx`):\n   - ✅ Now uses the new XState-based workflow component\n\n**Key Improvements:**\n- **State Management**: Clean XState machine with predictable state transitions\n- **Type Safety**: Proper TypeScript typing for all events and context\n- **UI/UX**: Clear step-by-step workflow with progress indication\n- **Error Handling**: Centralized error management through machine context\n- **Extensibility**: Easy to add new states, events, and actions\n\n**Ready for Testing:**\nThe application now has a fully functional project workflow using XState that follows the same patterns as the existing codebase.\n</info added on 2025-07-20T11:59:25.046Z>\n<info added on 2025-07-20T12:12:49.281Z>\n**ProjectContextView Component Added:**\n\nCreated `ProjectContextView` component following the same pattern as the existing `ContextView`:\n\n1. **Component Location**: `src/components/fs_components/ProjectContextView.tsx`\n2. **Features**:\n   - Settings icon button in top-right corner\n   - Dialog with project machine state and context display\n   - Uses `react-json-tree` for formatted JSON viewing\n   - Shows current state value and full context\n   - Integrated with `ProjectActorContext` hooks\n\n3. **Integration**: Added to main page (`src/app/page.tsx`) for debugging and monitoring\n\n4. **Machine Fixes**: \n   - Fixed commented out `SELECT_VIDEO` target\n   - Fixed relative target issue with `RESET` event\n   - All transitions now use absolute targets for XState v5 compatibility\n\n**Current Status**: The project workflow now has full debugging capabilities with real-time state monitoring through the context viewer.\n</info added on 2025-07-20T12:12:49.281Z>",
            "testStrategy": "Test project creation flow, project listing, and project selection. Verify UI responsiveness and user feedback."
          },
          {
            "id": 3,
            "title": "Implement browser-specific video file handling",
            "description": "Create video file access system that works across browsers with appropriate persistence strategies",
            "status": "done",
            "dependencies": [],
            "details": "Implement lib/video-file-handler.ts with browser detection and file access methods. Use File System Access API for Chromium browsers with file handle storage. Implement traditional file input for Firefox/Safari with file metadata storage. Create unified interface for video file access.\n<info added on 2025-07-20T12:29:30.911Z>\nXState v5 syntax has been corrected in the project workflow implementation. Fixed assign action destructuring from incorrect `(_, event)` to proper `({ event })` and `({ context, event })` patterns. Resolved duplicate provider issue that was causing \"stopped actor\" errors. Created comprehensive XState cursor rule documentation to prevent future syntax issues. The video file handling system now integrates properly with the corrected XState v5 project workflow state machine.\n</info added on 2025-07-20T12:29:30.911Z>\n<info added on 2025-07-20T12:45:00.000Z>\n**Browser-Specific Video File Handling Implementation Complete:**\n\n**Created Complete Video File Handler System:**\n\n1. **Video File Handler** (`src/lib/video-file-handler.ts`):\n   - ✅ Browser detection utility for Chromium vs other browsers\n   - ✅ File System Access API integration for Chromium browsers\n   - ✅ IndexedDB storage for persistent file handles\n   - ✅ Fallback file input system for Firefox/Safari\n   - ✅ Unified interface for video file access across browsers\n   - ✅ Blob URL creation and management\n   - ✅ File validation for supported video formats\n\n2. **EditProjectPage Integration** (`src/app/edit/[id]/page.tsx`):\n   - ✅ Video file restoration on project load\n   - ✅ Automatic file handle retrieval for Chromium browsers\n   - ✅ File re-linking UI for missing or inaccessible files\n   - ✅ Video display using blob URLs from all access methods\n   - ✅ Error handling for file access failures\n   - ✅ Seamless project continuation across browser sessions\n\n3. **Browser-Specific Persistence:**\n   - ✅ **Chromium**: File handles stored in IndexedDB for persistent access\n   - ✅ **Firefox/Safari**: File metadata stored with re-selection prompts\n   - ✅ Graceful degradation between browser capabilities\n   - ✅ Consistent user experience across all browsers\n\n**Key Features:**\n- **Persistent Access**: Chromium users can reopen projects and automatically access video files\n- **Cross-Browser Support**: Firefox/Safari users get file re-selection prompts\n- **Error Recovery**: Clear messaging and re-linking options for inaccessible files\n- **Memory Management**: Proper blob URL cleanup and resource management\n- **Format Support**: MP4, WebM, OGV validation and handling\n\n**System Status**: Video file handling is now fully implemented with browser-specific persistence strategies working seamlessly across all supported browsers.\n</info added on 2025-07-20T12:45:00.000Z>",
            "testStrategy": "Test video file selection and access across different browsers. Verify file handle persistence in Chromium browsers. Test file re-linking functionality for missing files."
          },
          {
            "id": 4,
            "title": "Build funscript file management",
            "description": "Implement funscript file upload, creation, and editing within project context",
            "status": "done",
            "dependencies": [],
            "details": "Create lib/funscript-handler.ts for funscript file operations. Support uploading existing .funscript files and creating new ones. Implement funscript data validation and parsing. Store funscript data within project structure.",
            "testStrategy": "Test funscript file upload, parsing, and validation. Verify funscript data storage and retrieval within projects."
          },
          {
            "id": 5,
            "title": "Create project workflow hook",
            "description": "Implement useProject hook for managing project state, video files, and funscript data",
            "status": "done",
            "dependencies": [
              1,
              3,
              4
            ],
            "details": "Create hooks/useProject.ts that manages current project state, handles video file loading, funscript data, and project persistence. Provide methods for creating, saving, and loading projects. Handle browser-specific file access and error states.",
            "testStrategy": "Test project state management, file loading, and persistence. Verify error handling for missing files or unsupported browsers."
          },
          {
            "id": 6,
            "title": "Implement project loading and restoration",
            "description": "Build system to automatically restore video and funscript content when reopening projects",
            "status": "done",
            "dependencies": [
              5
            ],
            "details": "Implement project restoration logic that loads video files (using stored handles or prompting for re-selection) and funscript data. Handle cases where video files are no longer accessible. Provide user feedback about restoration status.",
            "testStrategy": "Test project restoration across browser sessions. Verify handling of missing or inaccessible video files. Test user feedback and error recovery."
          },
          {
            "id": 7,
            "title": "Add file validation and error handling",
            "description": "Implement comprehensive validation for video formats, file sizes, and browser compatibility",
            "status": "done",
            "dependencies": [],
            "details": "Add validation for supported video formats (MP4, WebM, OGV), file size limits, and funscript format validation. Implement error handling for unsupported browsers, file access permissions, and corrupted files. Provide clear user feedback for all error conditions.",
            "testStrategy": "Test validation with various file types and sizes. Verify error handling for unsupported formats and browser limitations."
          },
          {
            "id": 8,
            "title": "Create project-aware video player component",
            "description": "Build video player component that integrates with project system and handles blob URLs from all file access methods",
            "status": "done",
            "dependencies": [
              5
            ],
            "details": "Create components/ProjectVideoPlayer.tsx that works with project-managed video files. Handle blob URL creation from file handles or file objects. Integrate with project state for automatic video loading and cleanup.",
            "testStrategy": "Test video playback with files from different access methods. Verify proper cleanup of blob URLs and memory management."
          },
          {
            "id": 9,
            "title": "Integrate video file handler with EditProjectPage",
            "description": "Update EditProjectPage to use the new video file handling system for seamless project continuation",
            "status": "done",
            "dependencies": [
              3
            ],
            "details": "Update EditProjectPage component to integrate with the video file handler system. Implement automatic video file restoration on project load, handle file re-linking for inaccessible files, and display videos using blob URLs from the unified file access system. Ensure proper error handling and user feedback for file access issues.",
            "testStrategy": "Test project loading with existing video files. Verify file restoration works across browser sessions in Chromium. Test file re-linking functionality when files are missing or inaccessible."
          }
        ]
      },
      {
        "id": 4,
        "title": "Create HTML5 Video Player Component",
        "description": "Build custom video player with standard controls and programmatic seek functionality for graph synchronization, integrating with MotionActorContext and FsEditActorContext",
        "status": "in-progress",
        "dependencies": [
          14
        ],
        "priority": "high",
        "details": "Create components/VideoPlayer.tsx using HTML5 video element or video.js library for advanced features. Integrate with MotionActorContext and FsEditActorContext for state management and synchronization. Implement custom controls: play/pause button, progress bar, volume control, fullscreen toggle. Add programmatic seek functionality via context and refs. Implement video event handlers (timeupdate, loadedmetadata, ended). Expose control APIs through context providers for external synchronization. Style with Tailwind CSS to match application theme. Ensure responsive design for different screen sizes. Integrate with project-based video file system to load video files from project data. Use video.js library where appropriate for advanced playback features while maintaining compatibility with existing context system.",
        "testStrategy": "Test video playbook across different browsers with both HTML5 and video.js implementations. Verify all controls function correctly and integrate properly with MotionActorContext and FsEditActorContext. Test programmatic seeking accuracy via context APIs. Validate responsive behavior on mobile devices. Test integration with project-based file loading system. Verify context synchronization works correctly with other components.",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up video.js library and basic component structure",
            "description": "Install video.js library and create basic VideoPlayer component structure in components/VideoPlayer.tsx",
            "status": "done",
            "dependencies": [],
            "details": "<info added on 2025-07-22T16:17:15.254Z>\nCompleted implementation of custom video controls component. Created VideoControls.tsx with play/pause, prev/next frame navigation, and zoom toggle buttons. Integrated with MotionActorContext and FsEditActorContext for state management. Removed \"Video Player\" heading from EditProjectPage and integrated custom controls above the video player. Used Tailwind CSS for styling with clean, modern design. Buttons are properly connected to XState actions for video control.\n</info added on 2025-07-22T16:17:15.254Z>",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Integrate with MotionActorContext and FsEditActorContext",
            "description": "Connect VideoPlayer component to existing context providers for state management and synchronization",
            "status": "done",
            "dependencies": [],
            "details": "<info added on 2025-07-22T16:34:36.806Z>\nRefactored video file handling architecture to follow better separation of concerns. Moved video file handling logic from EditProjectPage into a dedicated useVideoFileManager hook. Updated fsEditMachine to include videoPrompt in context and added new events for video file management (SET_VIDEO_URL, SET_VIDEO_PROMPT, RESTORE_VIDEO_FILE, SELECT_VIDEO_FILE). Modified VideoPlayer component to get videoUrl from XState context instead of props, eliminating prop drilling. The videoUrl and videoPrompt state now live in the fsEditMachine context, providing centralized state management for video-related functionality.\n</info added on 2025-07-22T16:34:36.806Z>",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement custom video controls with video.js",
            "description": "Create custom play/pause, progress bar, volume control, and fullscreen toggle using video.js API",
            "status": "done",
            "dependencies": [],
            "details": "<info added on 2025-07-22T16:56:18.434Z>\nImplemented VideoTimeline component using react-video-timelines-slider library. Created comprehensive timeline with chapter markers from funscript metadata.chapters and loop point controls. Added loopStart and loopEnd to fsEditMachine context with SET_LOOP_POINTS event and action. Timeline displays chapter boundaries as disabled intervals and allows setting loop ranges via selectedInterval. Added clickable chapter labels below timeline for quick navigation. Integrated timeline under VideoPlayer in EditProjectPage with proper styling and padding.\n</info added on 2025-07-22T16:56:18.434Z>\n<info added on 2025-07-22T17:04:33.944Z>\nFixed timeline display issues based on user feedback: 1) Reduced tick density from 60 to max 20 ticks (every 5 seconds) to eliminate smudged overlapping time labels, 2) Removed chapter disabledIntervals as requested for different handling approach, 3) Added custom CSS styling to make timeline background grey (#6b7280) with green selected area (#22c55e) for loop points, 4) Added white handles with green borders for better visibility on green background. Timeline now has clean, readable time labels and proper color scheme.\n</info added on 2025-07-22T17:04:33.944Z>",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Add programmatic seek functionality via context and refs",
            "description": "Expose seek and control APIs through context providers and component refs for external synchronization",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement video event handlers and context integration",
            "description": "Handle timeupdate, loadedmetadata, ended events and sync with MotionActorContext and FsEditActorContext",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Style component with Tailwind CSS and ensure responsive design",
            "description": "Apply consistent styling and ensure component works across different screen sizes",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Integrate with project-based video file system",
            "description": "Connect component to load video files from project data and handle file management",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Implement stacked range sliders for video time control",
            "description": "Create dual-slider system with bottom range selector and top chapter editor",
            "details": "Implement VideoTimeSlider component with two stacked sliders:\n\n1. **Bottom Slider (Range Selector)**:\n   - Range: 0 → ctx.videoDuration (full video length)\n   - Two handles: ctx.rangeStart and ctx.rangeEnd\n   - Sets the working range for the top slider\n   - Uses nouislider-react with simple range configuration\n\n2. **Top Slider (Chapter Editor)**:\n   - Range: ctx.rangeStart → ctx.rangeEnd (dynamic based on bottom slider)\n   - Multiple handles for chapter startTime and endTime\n   - Only shows chapters within the selected range\n   - Filters out chapters outside range to reduce visual clutter\n\n**State Management**:\n- Add rangeStart and rangeEnd to fsEditMachine context\n- Add SET_RANGE_START and SET_RANGE_END events\n- Filter chapters based on range selection\n- Update chapter handles when range changes\n\n**Visual Design**:\n- Bottom slider: Full width, clear handle distinction\n- Top slider: Positioned above, chapter labels overlaid\n- Responsive design for different screen sizes\n- Clear visual separation between sliders\n\n**Technical Implementation**:\n- Use nouislider-react for both sliders\n- Implement range filtering logic for chapter visibility\n- Handle positioning: direct time values for bottom, normalized for top\n- Real-time updates to XState context on slider changes\n<info added on 2025-07-25T14:01:27.697Z>\n**Implementation Complete:**\n\n**Created Stacked Range Sliders System:**\n\n1. **VideoRangeSlider Component** (`src/components/fs_components/VideoRangeSlider.tsx`):\n   - ✅ Bottom slider for range selection (0 → videoDuration)\n   - ✅ Two handles for rangeStart and rangeEnd\n   - ✅ Real-time updates to XState context\n   - ✅ Time formatting and tooltips\n   - ✅ Validation to ensure start < end\n\n2. **VideoChapterSlider Component** (`src/components/fs_components/VideoChapterSlider.tsx`):\n   - ✅ Top slider for chapter editing within selected range\n   - ✅ Dynamic range based on bottom slider selection\n   - ✅ Chapter filtering to show only chapters within range\n   - ✅ Handle positioning normalized to selected range\n   - ✅ Chapter labels overlaid at handle positions\n   - ✅ Real-time chapter updates\n\n3. **VideoTimeSliders Component** (`src/components/fs_components/VideoTimeSliders.tsx`):\n   - ✅ Stacked layout with clear visual separation\n   - ✅ Chapter Editor (top) and Range Selector (bottom)\n   - ✅ Range summary display\n   - ✅ Responsive design with proper spacing\n\n4. **XState Integration**:\n   - ✅ Added SET_RANGE_START, SET_RANGE_END, RESET_RANGE events\n   - ✅ Added corresponding actions in fsEditActions.ts\n   - ✅ rangeStart and rangeEnd already in context\n   - ✅ Proper state management and validation\n\n**Key Features Implemented:**\n- **Range Selection**: Bottom slider sets working range for top slider\n- **Chapter Filtering**: Only chapters within range are displayed\n- **Handle Positioning**: Bottom uses direct time values, top uses normalized positions\n- **Real-time Updates**: Changes immediately reflect in XState context\n- **Visual Design**: Clean stacked layout with proper labeling\n- **Performance**: Memoized calculations and efficient filtering\n\n**Ready for Testing:**\nThe stacked range sliders system is now fully implemented and ready for integration with the video player component.\n</info added on 2025-07-25T14:01:27.697Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 4
          },
          {
            "id": 9,
            "title": "Add range state management to fsEditMachine",
            "description": "Extend XState machine to support range selection and chapter filtering",
            "details": "Update fsEditMachine to support the stacked range slider functionality:\n\n**Context Updates**:\n- Add `rangeStart: number` to context (default: 0)\n- Add `rangeEnd: number` to context (default: videoDuration)\n- Ensure these values are properly initialized when video loads\n\n**New Events**:\n- `SET_RANGE_START`: Updates the start of the working range\n- `SET_RANGE_END`: Updates the end of the working range\n- `RESET_RANGE`: Resets range to full video duration\n\n**Actions**:\n- `updateRangeStart`: Updates context.rangeStart\n- `updateRangeEnd`: Updates context.rangeEnd\n- `resetRange`: Sets range to [0, videoDuration]\n\n**State Transitions**:\n- Handle range updates in all relevant states\n- Ensure range values are validated (rangeStart < rangeEnd)\n- Update range when video duration changes\n\n**Integration**:\n- Connect with VideoTimeSlider component\n- Provide selectors for range values\n- Ensure chapter filtering works with range changes\n<info added on 2025-07-25T14:12:19.098Z>\n**Implementation Complete:**\n\n**XState Machine Range Management Added:**\n\n1. **Events Added** (`src/lib/fs_machines/fsEditMachine.ts`):\n   - ✅ `SET_RANGE_START`: Updates the start of the working range\n   - ✅ `SET_RANGE_END`: Updates the end of the working range  \n   - ✅ `RESET_RANGE`: Resets range to full video duration\n\n2. **Actions Added** (`src/lib/fs_machines/fsEditActions.ts`):\n   - ✅ `setRangeStart`: Updates context.rangeStart\n   - ✅ `setRangeEnd`: Updates context.rangeEnd\n   - ✅ `resetRange`: Sets range to [0, videoDuration]\n\n3. **Context Already Available**:\n   - ✅ `rangeStart: number` already in FSEditContext\n   - ✅ `rangeEnd: number` already in FSEditContext\n   - ✅ Proper initialization in machine context\n\n4. **Integration**:\n   - ✅ Events connected to actions in machine definition\n   - ✅ Actions exported from fsEditActions\n   - ✅ Ready for use by VideoRangeSlider and VideoChapterSlider components\n\n**State Management Features:**\n- **Validation**: Range updates ensure start < end\n- **Initialization**: Range properly initialized when video loads\n- **Persistence**: Range state maintained across component updates\n- **Integration**: Seamless connection with slider components\n\n**Ready for Use:**\nThe XState machine now fully supports range selection and chapter filtering functionality.\n</info added on 2025-07-25T14:12:19.098Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 4
          },
          {
            "id": 10,
            "title": "Implement chapter filtering and handle positioning logic",
            "description": "Create logic to filter chapters by range and position handles correctly",
            "details": "Implement the core logic for chapter filtering and handle positioning:\n\n**Chapter Filtering Logic**:\n```typescript\n// Filter chapters to only show those within the selected range\nconst visibleChapters = chapters.filter(chapter => \n  chapter.startTime >= rangeStart && \n  chapter.endTime <= rangeEnd\n);\n```\n\n**Handle Positioning**:\n- **Bottom Slider**: Direct time values (0 to videoDuration)\n- **Top Slider**: Normalized to selected range (0 to 100% of rangeEnd - rangeStart)\n\n**Chapter Handle Calculation**:\n- Convert chapter times to normalized positions within selected range\n- Handle edge cases where chapters span range boundaries\n- Ensure handles don't exceed slider bounds\n\n**Real-time Updates**:\n- Recalculate handle positions when range changes\n- Update chapter visibility when range updates\n- Maintain handle positions during video playback\n\n**Performance Optimization**:\n- Memoize filtered chapters and handle positions\n- Debounce range updates to prevent excessive recalculations\n- Use efficient algorithms for large chapter counts\n<info added on 2025-07-25T14:12:44.684Z>\n**Implementation Complete:**\n\n**Chapter Filtering and Handle Positioning Logic Implemented:**\n\n1. **Chapter Filtering Logic** (`VideoChapterSlider.tsx`):\n   - ✅ Filter chapters to only show those within selected range\n   - ✅ `visibleChapters` computed with useMemo for performance\n   - ✅ Handles edge cases where chapters span range boundaries\n   - ✅ Graceful handling when no chapters in range\n\n2. **Handle Positioning System**:\n   - ✅ **Bottom Slider**: Direct time values (0 to videoDuration)\n   - ✅ **Top Slider**: Normalized to selected range (0 to 100% of rangeEnd - rangeStart)\n   - ✅ Chapter times converted to normalized positions within range\n   - ✅ Proper calculation: `((chapterTime - rangeStart) / (rangeEnd - rangeStart)) * 100`\n\n3. **Real-time Updates**:\n   - ✅ Recalculate handle positions when range changes\n   - ✅ Update chapter visibility when range updates\n   - ✅ Maintain handle positions during video playback\n   - ✅ Efficient updates with useCallback and useMemo\n\n4. **Performance Optimization**:\n   - ✅ Memoized filtered chapters with useMemo\n   - ✅ Memoized handle positions calculation\n   - ✅ Debounced range updates in slider components\n   - ✅ Efficient algorithms for large chapter counts\n\n5. **Edge Case Handling**:\n   - ✅ Invalid ranges (rangeEnd <= rangeStart)\n   - ✅ Empty chapter arrays\n   - ✅ Chapters outside selected range\n   - ✅ Proper fallback UI for no chapters in range\n\n**Key Features:**\n- **Dynamic Filtering**: Chapters automatically filtered based on range selection\n- **Precise Positioning**: Handles positioned accurately within selected range\n- **Performance**: Optimized calculations prevent unnecessary re-renders\n- **Robustness**: Handles all edge cases gracefully\n\n**Ready for Integration:**\nThe chapter filtering and handle positioning logic is fully implemented and ready for use with the stacked range sliders.\n</info added on 2025-07-25T14:12:44.684Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 4
          },
          {
            "id": 11,
            "title": "Implement chapter editing popover with form validation",
            "description": "Transform chapter labels into interactive buttons with popover forms for editing chapter properties",
            "details": "Transform the chapter labels in VideoChapterSlider into interactive buttons with the following features:\n\n1. **Button Layout**:\n   - Keep all chapters visible (don't filter by range)\n   - Place in horizontally scrollable container\n   - Handle overflow when many chapters exist\n\n2. **Popover Form**:\n   - Click button opens popover with edit form\n   - Form fields: title, startTime, endTime\n   - Cancel and Save buttons\n\n3. **Validation Logic**:\n   - Start time must be after previous chapter's end time\n   - End time must be before next chapter's start time\n   - Show red input styling and error messages for invalid times\n   - Error messages: \"end time must be before the next chapter's (chapter name) start time\" or \"start time must be after the previous chapter's (chapter name) end time\"\n\n4. **Implementation Details**:\n   - Use Radix UI Popover component\n   - Use Shadcn/ui form components\n   - Integrate with existing XState context for chapter updates\n   - Maintain real-time validation during form input\n   - Handle edge cases (first/last chapters)\n\n5. **UI/UX**:\n   - Smooth animations for popover open/close\n   - Clear visual feedback for validation errors\n   - Responsive design for different screen sizes\n   - Keyboard navigation support",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 4
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement Funscript File Parser and Validator",
        "description": "Create system to upload, parse, validate, and store Funscript JSON files with proper error handling and project-based database integration",
        "status": "pending",
        "dependencies": [
          14
        ],
        "priority": "high",
        "details": "Create lib/funscript-parser.ts with project-aware functions: parseFunscript(file: File), validateFunscript(data: any), exportFunscript(data: FunscriptObject), saveFunscriptToProject(data: FunscriptObject, projectId: string), loadFunscriptFromProject(projectId: string), updateFunscriptInProject(data: FunscriptObject, projectId: string). Implement JSON parsing with try-catch error handling. Validate required fields (actions array, version) and store validation results in project data. Sort actions by timestamp. Handle malformed data gracefully. Create components/FunscriptUpload.tsx for file upload UI. Integrate with project-based workflow to automatically associate Funscript files with the current project.",
        "testStrategy": "Test with valid and invalid Funscript files. Verify error messages for malformed JSON. Test large file handling. Validate sorting and data integrity after parsing. Test integration with project-based storage system. Verify versioning system preserves edit history within projects. Test retrieval and update operations. Validate relationships between Funscript files and video projects. Test project-based organization and listing functionality.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create core parser functions in lib/funscript-parser.ts",
            "description": "Implement basic parsing, validation, and export functions with error handling",
            "status": "pending",
            "dependencies": [],
            "details": "Implement parseFunscript(file: File), validateFunscript(data: any), and exportFunscript(data: FunscriptObject) functions with comprehensive error handling for malformed JSON and missing required fields.",
            "testStrategy": "Test with valid and invalid Funscript files. Verify error messages for malformed JSON. Test handling of missing required fields."
          },
          {
            "id": 2,
            "title": "Create database abstraction layer",
            "description": "Implement localStorage-based database provider with interfaces for all data models",
            "status": "pending",
            "dependencies": [],
            "details": "Create lib/db/ directory with lib/db/localStorage.ts as the initial database provider and lib/db/types.ts with interfaces for FunscriptData, ROIData, MotionCaptureData, EditHistoryEntry, and ProjectSettings. Implement basic CRUD operations for all data types. Define data models: FunscriptData: { id, projectId, content, createdAt, updatedAt }, ROIData: { id, projectId, regions: [{ start, end, name, color }], createdAt, updatedAt }, MotionCaptureData: { id, projectId, data, createdAt, updatedAt }, EditHistoryEntry: { id, projectId, funscriptId, timestamp, changes, snapshot }, ProjectSettings: { id, name, settings, createdAt, updatedAt }.",
            "testStrategy": "Test localStorage persistence and retrieval. Verify data model integrity and type safety. Test edge cases like storage limits and data corruption."
          },
          {
            "id": 3,
            "title": "Implement database integration functions",
            "description": "Create database operations for Funscript and related data",
            "status": "pending",
            "dependencies": [
              2
            ],
            "details": "Implement saveFunscriptToDb(data, projectId), loadFunscriptFromDb(projectId), updateFunscriptVersion(data, projectId), saveROIData(roiData, funscriptId), saveMotionCaptureData(motionData, funscriptId), getEditHistory(funscriptId), createProject(name, settings), and listProjects() functions.",
            "testStrategy": "Test all database operations with sample data. Verify data integrity after save and load operations. Test error handling for database operations."
          },
          {
            "id": 4,
            "title": "Implement versioning system",
            "description": "Add functionality to track edit history with timestamps and change descriptions",
            "status": "pending",
            "dependencies": [
              2,
              3
            ],
            "details": "Create system to track edit history with timestamps, change descriptions, and snapshots. Implement getEditHistory function to retrieve version history for a Funscript.",
            "testStrategy": "Test version history creation and retrieval. Verify timestamps and change descriptions are accurate. Test with multiple edits to ensure history is maintained correctly."
          },
          {
            "id": 5,
            "title": "Create project association system",
            "description": "Implement linking between Funscript files and video files via project IDs",
            "status": "pending",
            "dependencies": [
              2,
              3
            ],
            "details": "Implement project-based organization for all data. Create functions to associate Funscript files with video files via project IDs. Implement createProject and listProjects functions.",
            "testStrategy": "Test project creation and listing. Verify associations between Funscript files and video files. Test project-based data organization."
          },
          {
            "id": 6,
            "title": "Update FunscriptUpload component",
            "description": "Modify UI to work with database layer instead of direct file handling",
            "status": "pending",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Update components/FunscriptUpload.tsx to use the database abstraction layer for file uploads and storage. Implement project selection in the UI.",
            "testStrategy": "Test file upload with the new database layer. Verify UI feedback during upload and processing. Test project selection functionality."
          },
          {
            "id": 7,
            "title": "Implement version history viewer",
            "description": "Create UI component to view and restore previous versions of Funscript files",
            "status": "pending",
            "dependencies": [
              4
            ],
            "details": "Create UI component to view and restore previous versions of Funscript files using the edit history data from the database.",
            "testStrategy": "Test version history display and restoration. Verify UI accurately shows version differences. Test restoration of previous versions."
          },
          {
            "id": 8,
            "title": "Add export options for database-stored Funscripts",
            "description": "Implement functionality to export Funscript data from database to file",
            "status": "pending",
            "dependencies": [
              3
            ],
            "details": "Implement functionality to export Funscript data from database to file. Add options for exporting with or without ROI and motion capture data.",
            "testStrategy": "Test export functionality with various data combinations. Verify exported files match database content. Test with large datasets."
          },
          {
            "id": 9,
            "title": "Implement soft delete for version management",
            "description": "Add functionality to mark versions as deleted without removing them from the database",
            "status": "pending",
            "dependencies": [
              4
            ],
            "details": "Implement soft delete functionality to mark versions as deleted without removing them from the database. Add UI options to show or hide deleted versions.",
            "testStrategy": "Test soft delete functionality. Verify deleted versions are hidden by default but can be shown. Test restoration of soft-deleted versions."
          },
          {
            "id": 10,
            "title": "Create ROI data management functions",
            "description": "Implement functions to save, load, and update ROI data",
            "status": "pending",
            "dependencies": [
              2,
              3
            ],
            "details": "Create functions to manage Regions of Interest (ROI) data associated with Funscript files. Implement saveROIData, loadROIData, and updateROIData functions.",
            "testStrategy": "Test ROI data management functions with sample data. Verify data integrity after save and load operations. Test with complex region definitions."
          },
          {
            "id": 11,
            "title": "Implement motion capture data integration",
            "description": "Add support for storing and retrieving motion capture data",
            "status": "pending",
            "dependencies": [
              2,
              3
            ],
            "details": "Implement functions to store and retrieve motion capture data associated with Funscript files. Create saveMotionCaptureData and loadMotionCaptureData functions.",
            "testStrategy": "Test motion capture data storage and retrieval. Verify data integrity with large motion datasets. Test integration with Funscript data."
          },
          {
            "id": 12,
            "title": "Create migration utilities for Supabase transition",
            "description": "Implement utilities to facilitate future migration to Supabase",
            "status": "pending",
            "dependencies": [
              2,
              3
            ],
            "details": "Create utilities to export data from localStorage and import it into Supabase. Design database abstraction layer to make transition seamless.",
            "testStrategy": "Test data export and import utilities. Verify data integrity after migration. Test with large datasets to ensure all data is preserved."
          }
        ]
      },
      {
        "id": 6,
        "title": "Build Interactive Graph Visualization with Chart.js",
        "description": "Create the core graph component to visualize Funscript position data over time using Chart.js with project-based data integration",
        "details": "Create components/FSGraph.tsx using Chart.js line chart. Configure chart options: responsive: true, maintainAspectRatio: false, scales with time (x-axis) and position 0-100 (y-axis). Implement data transformation from FunscriptAction[] to Chart.js dataset format. Add zoom and pan plugins. Style with custom colors and grid lines. Create useFSGraph hook for chart state management. Implement click-to-seek functionality that updates video player time. Integrate with project system to load and display Funscript data from the current project.",
        "testStrategy": "Test graph rendering with sample Funscript data. Verify zoom and pan functionality. Test click-to-seek integration with video player. Validate performance with large datasets (1000+ points). Test integration with project-based data loading system.",
        "priority": "high",
        "dependencies": [
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Video-Graph Synchronization System",
        "description": "Create real-time synchronization between video playback position and graph cursor with frame indicator using project data",
        "details": "Create lib/synchronization.ts with sync logic. Implement video timeupdate event handler that updates graph cursor position. Add vertical line indicator on graph showing current video time. Create bidirectional sync: video seeks update graph, graph clicks seek video. Use XState for synchronization state machine with states: idle, playing, seeking. Handle edge cases like rapid seeking and playback rate changes. Implement debouncing for smooth performance. Integrate with project system to maintain synchronization state per project.",
        "testStrategy": "Test synchronization accuracy with frame-by-frame video stepping. Verify cursor position updates during playback. Test rapid seeking scenarios. Validate performance during continuous playback. Test project-based synchronization state persistence.",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Add Drag-and-Drop Point Editing to Graph",
        "description": "Implement interactive editing functionality allowing users to drag position points on the graph with project-based persistence",
        "details": "Extend FSGraph component with Chart.js drag plugin. Implement mouse event handlers: onMouseDown, onMouseMove, onMouseUp. Add point selection logic with visual feedback (highlight selected points). Implement drag constraints (position 0-100, time boundaries). Update Funscript data in real-time during drag operations. Add hover effects and cursor changes. Implement touch support for mobile devices. Create undo/redo system using command pattern. Automatically save changes to project data and maintain edit history.",
        "testStrategy": "Test drag functionality across different browsers. Verify constraints prevent invalid values. Test undo/redo operations. Validate touch interactions on mobile devices. Test performance with multiple simultaneous drags. Verify changes are properly saved to project data.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Multi-Point Selection and Bulk Operations",
        "description": "Add ability to select multiple points using keyboard modifiers and perform bulk editing operations with project-based persistence",
        "details": "Extend graph interaction to support Ctrl+click and Shift+click for multi-selection. Implement selection rectangle with mouse drag. Add visual indicators for selected points (different color/border). Create bulk operations: delete selected, move selected, copy/paste. Implement keyboard shortcuts: Ctrl+A (select all), Delete (remove selected), Ctrl+C/V (copy/paste). Add selection state to XState machine. Create context menu for right-click operations. Ensure all bulk operations are saved to project data with proper edit history tracking.",
        "testStrategy": "Test multi-selection with various keyboard combinations. Verify bulk operations work correctly. Test copy/paste functionality. Validate keyboard shortcuts across different operating systems. Verify bulk changes are properly tracked in project edit history.",
        "priority": "medium",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Create Funscript Export and Download System",
        "description": "Implement functionality to export edited Funscript data as downloadable JSON files from project data",
        "details": "Create lib/export.ts with exportFunscript function. Generate valid Funscript JSON with metadata (version, range, inverted). Implement browser download using Blob and URL.createObjectURL. Add export options: filename customization, metadata inclusion. Create export button in UI with download progress indicator. Validate exported data matches Funscript 1.0 specification. Add export history and recent files list in project data. Support exporting from current project or specific project versions.",
        "testStrategy": "Test exported files can be re-imported successfully. Verify JSON structure matches Funscript specification. Test download functionality across browsers. Validate metadata preservation during export. Test exporting from different project versions.",
        "priority": "medium",
        "dependencies": [
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Build Main Application Layout and Navigation",
        "description": "Create the main application layout with video player, graph editor, and control panels using Shadcn/ui components with project-based workflow",
        "details": "Create app/page.tsx as main layout. Implement responsive grid layout: video player (top-left), graph editor (bottom), controls (top-right). Use Shadcn/ui components: Button, Card, Separator, Tabs. Add theme provider for dark/light mode support. Implement collapsible panels and resizable sections. Create navigation breadcrumbs and status indicators. Add loading states and error boundaries. Implement keyboard navigation and focus management for accessibility. Add project selector and project management UI elements to the main layout.",
        "testStrategy": "Test layout responsiveness across screen sizes. Verify theme switching functionality. Test keyboard navigation and screen reader compatibility. Validate loading states and error handling. Test project selection and management UI integration.",
        "priority": "medium",
        "dependencies": [
          10
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement State Management with XState and Zustand Integration",
        "description": "Create comprehensive state management system using XState for complex editor states and Zustand for simpler component state with project-based state persistence",
        "details": "Create stores/fsEditActor.ts with XState machine for editor states: idle, loading, editing, exporting. Implement state transitions and guards for valid operations. Create stores/videoStore.ts with Zustand for video state. Create stores/graphStore.ts for graph interaction state. Create stores/projectStore.ts for project management state. Implement state persistence using project-based storage. Add state debugging tools and dev mode logging. Create custom hooks for state access: useEditorState, useVideoState, useGraphState, useProjectState. Handle state hydration and error recovery with project context.",
        "testStrategy": "Test state transitions and edge cases. Verify state persistence across browser sessions. Test concurrent state updates. Validate state debugging tools in development mode. Test project-based state isolation and switching between projects.",
        "priority": "medium",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Create Mock Database Layer with localStorage",
        "description": "Implement a database abstraction layer using localStorage that can be easily migrated to Supabase later, handling storage of Funscript files, ROI data, motion capture data, edit history, and project settings.",
        "details": "1. Create a `lib/db/` directory structure for the database abstraction layer:\n   - `lib/db/index.ts`: Main entry point exporting all database functionality\n   - `lib/db/types.ts`: Define interfaces for all data models and database operations\n   - `lib/db/localStorage.ts`: Implementation using browser's localStorage\n   - `lib/db/migrations.ts`: Utilities for future data migration to Supabase\n\n2. In `lib/db/types.ts`, define the following interfaces:\n   ```typescript\n   // Database provider interface\n   export interface DatabaseProvider {\n     // CRUD operations\n     getItem<T>(collection: string, id: string): Promise<T | null>;\n     setItem<T>(collection: string, id: string, data: T): Promise<void>;\n     removeItem(collection: string, id: string): Promise<void>;\n     listItems<T>(collection: string, query?: QueryParams): Promise<T[]>;\n     \n     // Collection operations\n     createCollection(name: string): Promise<void>;\n     dropCollection(name: string): Promise<void>;\n     \n     // Utility methods\n     clear(): Promise<void>;\n     migrate(provider: DatabaseProvider): Promise<void>;\n   }\n   \n   // Query parameters for filtering data\n   export interface QueryParams {\n     filters?: Record<string, any>;\n     limit?: number;\n     offset?: number;\n     orderBy?: string;\n     orderDirection?: 'asc' | 'desc';\n   }\n   \n   // Data models\n   export interface FunscriptData {\n     id: string;\n     name: string;\n     content: any; // The actual Funscript JSON\n     createdAt: number;\n     updatedAt: number;\n   }\n   \n   export interface ROIData {\n     id: string;\n     funscriptId: string;\n     regions: Array<{\n       start: number;\n       end: number;\n       name: string;\n       color?: string;\n     }>;\n     createdAt: number;\n     updatedAt: number;\n   }\n   \n   export interface MotionCaptureData {\n     id: string;\n     funscriptId: string;\n     data: any; // Motion capture data structure\n     createdAt: number;\n     updatedAt: number;\n   }\n   \n   export interface EditHistoryEntry {\n     id: string;\n     funscriptId: string;\n     timestamp: number;\n     changes: any; // Description of changes made\n     snapshot: any; // Optional full snapshot of data at this point\n   }\n   \n   export interface ProjectSettings {\n     id: string;\n     name: string;\n     settings: Record<string, any>;\n     createdAt: number;\n     updatedAt: number;\n   }\n   ```\n\n3. Implement `lib/db/localStorage.ts`:\n   ```typescript\n   import { DatabaseProvider, QueryParams } from './types';\n   \n   export class LocalStorageProvider implements DatabaseProvider {\n     private prefix = 'pfs-editor-';\n     \n     // Helper to get collection key\n     private getCollectionKey(collection: string): string {\n       return `${this.prefix}${collection}`;\n     }\n     \n     // Helper to get item key\n     private getItemKey(collection: string, id: string): string {\n       return `${this.prefix}${collection}:${id}`;\n     }\n     \n     // Helper to parse stored JSON data\n     private parseItem<T>(data: string | null): T | null {\n       if (!data) return null;\n       try {\n         return JSON.parse(data) as T;\n       } catch (e) {\n         console.error('Failed to parse stored data:', e);\n         return null;\n       }\n     }\n     \n     // CRUD implementations\n     async getItem<T>(collection: string, id: string): Promise<T | null> {\n       const data = localStorage.getItem(this.getItemKey(collection, id));\n       return this.parseItem<T>(data);\n     }\n     \n     async setItem<T>(collection: string, id: string, data: T): Promise<void> {\n       try {\n         // Ensure collection exists in index\n         await this.ensureCollection(collection);\n         \n         // Store the item\n         localStorage.setItem(\n           this.getItemKey(collection, id),\n           JSON.stringify(data)\n         );\n         \n         // Update collection index\n         const index = await this.getCollectionIndex(collection);\n         if (!index.includes(id)) {\n           index.push(id);\n           await this.setCollectionIndex(collection, index);\n         }\n       } catch (e) {\n         console.error('Failed to store item:', e);\n         throw new Error(`Storage error: ${e.message}`);\n       }\n     }\n     \n     async removeItem(collection: string, id: string): Promise<void> {\n       localStorage.removeItem(this.getItemKey(collection, id));\n       \n       // Update collection index\n       const index = await this.getCollectionIndex(collection);\n       const newIndex = index.filter(itemId => itemId !== id);\n       await this.setCollectionIndex(collection, newIndex);\n     }\n     \n     async listItems<T>(collection: string, query?: QueryParams): Promise<T[]> {\n       const index = await this.getCollectionIndex(collection);\n       const items: T[] = [];\n       \n       for (const id of index) {\n         const item = await this.getItem<T>(collection, id);\n         if (item) {\n           // Apply filters if provided\n           if (query?.filters && !this.matchesFilters(item, query.filters)) {\n             continue;\n           }\n           items.push(item);\n         }\n       }\n       \n       // Apply sorting if needed\n       if (query?.orderBy) {\n         items.sort((a, b) => {\n           const aVal = a[query.orderBy];\n           const bVal = b[query.orderBy];\n           const direction = query.orderDirection === 'desc' ? -1 : 1;\n           \n           if (aVal < bVal) return -1 * direction;\n           if (aVal > bVal) return 1 * direction;\n           return 0;\n         });\n       }\n       \n       // Apply pagination if needed\n       if (query?.offset || query?.limit) {\n         const offset = query.offset || 0;\n         const limit = query.limit || items.length;\n         return items.slice(offset, offset + limit);\n       }\n       \n       return items;\n     }\n     \n     // Collection operations\n     private async getCollectionIndex(collection: string): Promise<string[]> {\n       const key = this.getCollectionKey(collection);\n       const data = localStorage.getItem(key);\n       return this.parseItem<string[]>(data) || [];\n     }\n     \n     private async setCollectionIndex(collection: string, index: string[]): Promise<void> {\n       const key = this.getCollectionKey(collection);\n       localStorage.setItem(key, JSON.stringify(index));\n     }\n     \n     private async ensureCollection(collection: string): Promise<void> {\n       const key = this.getCollectionKey(collection);\n       if (!localStorage.getItem(key)) {\n         localStorage.setItem(key, JSON.stringify([]));\n       }\n     }\n     \n     async createCollection(name: string): Promise<void> {\n       await this.ensureCollection(name);\n     }\n     \n     async dropCollection(name: string): Promise<void> {\n       // Get all items in the collection\n       const index = await this.getCollectionIndex(name);\n       \n       // Remove each item\n       for (const id of index) {\n         localStorage.removeItem(this.getItemKey(name, id));\n       }\n       \n       // Remove the collection index\n       localStorage.removeItem(this.getCollectionKey(name));\n     }\n     \n     // Utility methods\n     async clear(): Promise<void> {\n       // Only clear items with our prefix\n       for (let i = 0; i < localStorage.length; i++) {\n         const key = localStorage.key(i);\n         if (key.startsWith(this.prefix)) {\n           localStorage.removeItem(key);\n         }\n       }\n     }\n     \n     async migrate(provider: DatabaseProvider): Promise<void> {\n       // This would be implemented when Supabase is ready\n       // It would iterate through all collections and items\n       // and copy them to the new provider\n     }\n     \n     // Helper for filtering\n     private matchesFilters<T>(item: T, filters: Record<string, any>): boolean {\n       for (const [key, value] of Object.entries(filters)) {\n         if (item[key] !== value) {\n           return false;\n         }\n       }\n       return true;\n     }\n   }\n   ```\n\n4. Create `lib/db/index.ts` to export the database functionality:\n   ```typescript\n   import { LocalStorageProvider } from './localStorage';\n   import type { DatabaseProvider } from './types';\n   \n   // Export all types\n   export * from './types';\n   \n   // Create and export the database instance\n   const db: DatabaseProvider = new LocalStorageProvider();\n   \n   // Initialize standard collections\n   const initializeDatabase = async () => {\n     await db.createCollection('funscripts');\n     await db.createCollection('roi');\n     await db.createCollection('motioncapture');\n     await db.createCollection('history');\n     await db.createCollection('settings');\n   };\n   \n   // Initialize on import\n   initializeDatabase().catch(console.error);\n   \n   export { db };\n   ```\n\n5. Create `lib/db/migrations.ts` for future Supabase migration:\n   ```typescript\n   import { db } from './index';\n   import type { DatabaseProvider } from './types';\n   \n   export async function exportDatabaseDump(): Promise<string> {\n     const collections = ['funscripts', 'roi', 'motioncapture', 'history', 'settings'];\n     const dump: Record<string, any[]> = {};\n     \n     for (const collection of collections) {\n       dump[collection] = await db.listItems(collection);\n     }\n     \n     return JSON.stringify(dump);\n   }\n   \n   export async function importDatabaseDump(json: string): Promise<void> {\n     try {\n       const dump = JSON.parse(json);\n       \n       // Clear existing data\n       await db.clear();\n       \n       // Import each collection\n       for (const [collection, items] of Object.entries(dump)) {\n         await db.createCollection(collection);\n         \n         for (const item of items) {\n           await db.setItem(collection, item.id, item);\n         }\n       }\n     } catch (e) {\n       console.error('Failed to import database dump:', e);\n       throw new Error(`Import failed: ${e.message}`);\n     }\n   }\n   \n   export async function migrateToProvider(newProvider: DatabaseProvider): Promise<void> {\n     await db.migrate(newProvider);\n   }\n   ```\n\n6. Create a simple hook for using the database in components:\n   ```typescript\n   // lib/hooks/useDatabase.ts\n   import { useCallback } from 'react';\n   import { db } from '../db';\n   import type { QueryParams } from '../db/types';\n   \n   export function useDatabase() {\n     const getFunscript = useCallback(async (id: string) => {\n       return db.getItem('funscripts', id);\n     }, []);\n     \n     const saveFunscript = useCallback(async (id: string, data: any) => {\n       return db.setItem('funscripts', id, {\n         id,\n         content: data,\n         updatedAt: Date.now(),\n         ...data\n       });\n     }, []);\n     \n     // Add similar methods for other data types\n     \n     return {\n       db,\n       getFunscript,\n       saveFunscript,\n       // ... other convenience methods\n     };\n   }\n   ```\n\n7. Implement storage size monitoring and quota management:\n   ```typescript\n   // Add to LocalStorageProvider class\n   async getStorageUsage(): Promise<{ used: number, quota: number }> {\n     let used = 0;\n     for (let i = 0; i < localStorage.length; i++) {\n       const key = localStorage.key(i);\n       if (key.startsWith(this.prefix)) {\n         const value = localStorage.getItem(key) || '';\n         used += key.length + value.length;\n       }\n     }\n     \n     // Convert to bytes (approximate)\n     used = used * 2; // UTF-16 characters are 2 bytes each\n     \n     // Estimate quota (typically 5-10MB)\n     const quota = 5 * 1024 * 1024; // 5MB\n     \n     return { used, quota };\n   }\n   ```",
        "testStrategy": "1. **Unit Testing Database Provider Interface**:\n   - Create a test suite for the LocalStorageProvider class\n   - Test each CRUD operation individually:\n     - Test `getItem` with existing and non-existing items\n     - Test `setItem` with new and updated items\n     - Test `removeItem` functionality\n     - Test `listItems` with various query parameters\n   - Test collection operations:\n     - Test `createCollection` creates new collections\n     - Test `dropCollection` removes all collection data\n   - Test utility methods:\n     - Test `clear` removes all database data\n     - Test storage usage calculation\n\n2. **Integration Testing with Mock Data**:\n   - Create a test suite that simulates real application usage\n   - Test storing and retrieving Funscript files:\n     ```typescript\n     const funscript = {\n       id: 'test-1',\n       name: 'Test Funscript',\n       content: { version: '1.0', actions: [{ at: 100, pos: 50 }] },\n       createdAt: Date.now(),\n       updatedAt: Date.now()\n     };\n     await db.setItem('funscripts', funscript.id, funscript);\n     const retrieved = await db.getItem('funscripts', 'test-1');\n     expect(retrieved).toEqual(funscript);\n     ```\n   - Test storing and retrieving ROI data\n   - Test storing and retrieving motion capture data\n   - Test edit history functionality\n   - Test project settings storage\n\n3. **Performance Testing**:\n   - Test with large datasets (100+ Funscript files)\n   - Measure read/write performance\n   - Test storage limits by filling localStorage to near capacity\n   - Implement and test pagination for large collections\n\n4. **Error Handling Testing**:\n   - Test behavior when localStorage is full\n   - Test with malformed JSON data\n   - Test with missing or invalid collection names\n   - Verify error messages are descriptive and helpful\n\n5. **Migration Testing**:\n   - Create mock Supabase provider that implements DatabaseProvider interface\n   - Test migration from localStorage to mock Supabase provider\n   - Verify all data is correctly transferred\n   - Test import/export functionality with sample database dumps\n\n6. **Browser Compatibility Testing**:\n   - Test in Chrome, Firefox, Safari, and Edge\n   - Verify localStorage behavior is consistent across browsers\n   - Test with private browsing mode enabled\n   - Verify storage persistence across browser sessions\n\n7. **React Component Integration**:\n   - Create test components that use the database hooks\n   - Test database operations from within React components\n   - Verify state updates correctly after database operations\n   - Test error handling in UI components\n\n8. **Manual Testing Checklist**:\n   - Verify data persistence after browser refresh\n   - Test storage and retrieval of all data types\n   - Verify query filtering works correctly\n   - Test storage quota monitoring\n   - Verify clear functionality works as expected",
        "status": "pending",
        "dependencies": [
          14
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Create Database Abstraction Layer with Storage Provider Interface",
        "description": "Implement a simplified project-focused storage system using localStorage initially but can be easily migrated to Supabase later, providing a consistent interface for storing project metadata, video file references, and funscript data.",
        "status": "done",
        "dependencies": [
          2
        ],
        "priority": "high",
        "details": "1. Create a `lib/db/` directory structure with the following files:\n   - `lib/db/index.ts`: Main entry point exporting the database API\n   - `lib/db/types.ts`: Define interfaces for project data models and storage providers\n   - `lib/db/localStorage.ts`: Implementation using browser's localStorage\n   - `lib/db/providers/base.ts`: Abstract base provider class\n\n2. In `lib/db/types.ts`, define the following simplified interfaces:\n   ```typescript\n   // Core project data model\n   export interface Project {\n     id: string;\n     name: string;\n     createdAt: number;\n     updatedAt: number;\n     videoFile?: {\n       name: string;\n       size: number;\n       type: string;\n       handle?: FileSystemFileHandle; // For Chromium browsers\n       lastModified?: number;\n     };\n     funscriptData?: {\n       version: string;\n       range: number;\n       inverted: boolean;\n       actions: Array<{\n         at: number;\n         pos: number;\n       }>;\n     };\n     settings?: {\n       playbackRate?: number;\n       volume?: number;\n       graphZoom?: number;\n       [key: string]: any;\n     };\n   }\n   ```\n\n3. Create a simplified storage provider interface in `lib/db/providers/base.ts`:\n   ```typescript\n   export interface StorageProvider {\n     // Project CRUD operations\n     getProject(id: string): Promise<Project | null>;\n     getAllProjects(): Promise<Project[]>;\n     saveProject(project: Project): Promise<Project>;\n     deleteProject(id: string): Promise<boolean>;\n     \n     // Utility operations\n     clear(): Promise<boolean>;\n   }\n   \n   export abstract class BaseStorageProvider implements StorageProvider {\n     abstract getProject(id: string): Promise<Project | null>;\n     abstract getAllProjects(): Promise<Project[]>;\n     abstract saveProject(project: Project): Promise<Project>;\n     abstract deleteProject(id: string): Promise<boolean>;\n     abstract clear(): Promise<boolean>;\n     \n     // Helper to generate unique IDs\n     generateId(): string {\n       return Date.now().toString(36) + Math.random().toString(36).substring(2);\n     }\n   }\n   ```\n\n4. Implement the localStorage provider in `lib/db/localStorage.ts`:\n   ```typescript\n   import { BaseStorageProvider } from './providers/base';\n   import type { Project } from './types';\n   \n   export class LocalStorageProvider extends BaseStorageProvider {\n     private readonly STORAGE_KEY = 'pfs-editor-projects';\n     \n     private getStoredProjects(): Project[] {\n       try {\n         const data = localStorage.getItem(this.STORAGE_KEY);\n         return data ? JSON.parse(data) : [];\n       } catch (error) {\n         console.error('Failed to parse stored projects:', error);\n         return [];\n       }\n     }\n     \n     private saveStoredProjects(projects: Project[]): void {\n       try {\n         localStorage.setItem(this.STORAGE_KEY, JSON.stringify(projects));\n       } catch (error) {\n         console.error('Failed to save projects:', error);\n         throw new Error('Storage quota exceeded or localStorage unavailable');\n       }\n     }\n     \n     async getProject(id: string): Promise<Project | null> {\n       const projects = this.getStoredProjects();\n       return projects.find(p => p.id === id) || null;\n     }\n     \n     async getAllProjects(): Promise<Project[]> {\n       return this.getStoredProjects();\n     }\n     \n     async saveProject(project: Project): Promise<Project> {\n       const projects = this.getStoredProjects();\n       const existingIndex = projects.findIndex(p => p.id === project.id);\n       \n       const updatedProject = {\n         ...project,\n         updatedAt: Date.now()\n       };\n       \n       if (existingIndex >= 0) {\n         projects[existingIndex] = updatedProject;\n       } else {\n         projects.push(updatedProject);\n       }\n       \n       this.saveStoredProjects(projects);\n       return updatedProject;\n     }\n     \n     async deleteProject(id: string): Promise<boolean> {\n       const projects = this.getStoredProjects();\n       const filteredProjects = projects.filter(p => p.id !== id);\n       \n       if (filteredProjects.length === projects.length) {\n         return false; // Project not found\n       }\n       \n       this.saveStoredProjects(filteredProjects);\n       return true;\n     }\n     \n     async clear(): Promise<boolean> {\n       try {\n         localStorage.removeItem(this.STORAGE_KEY);\n         return true;\n       } catch (error) {\n         console.error('Failed to clear projects:', error);\n         return false;\n       }\n     }\n   }\n   ```\n\n5. Create the main database API in `lib/db/index.ts`:\n   ```typescript\n   import { LocalStorageProvider } from './localStorage';\n   import type { Project } from './types';\n   \n   // Use localStorage provider initially\n   const storageProvider = new LocalStorageProvider();\n   \n   // Database API\n   export const db = {\n     // Project operations\n     getProject: (id: string) => storageProvider.getProject(id),\n     getAllProjects: () => storageProvider.getAllProjects(),\n     saveProject: (project: Project) => storageProvider.saveProject(project),\n     deleteProject: (id: string) => storageProvider.deleteProject(id),\n     \n     // Utility operations\n     createProject: (name: string): Project => {\n       return {\n         id: storageProvider.generateId(),\n         name,\n         createdAt: Date.now(),\n         updatedAt: Date.now()\n       };\n     },\n     \n     // Helper to generate unique IDs\n     generateId: () => storageProvider.generateId(),\n     \n     // Clear all data (useful for testing)\n     clear: () => storageProvider.clear()\n   };\n   \n   // Export types\n   export type { Project };\n   export { LocalStorageProvider };\n   ```\n\n6. Create a utility for future migration to Supabase in `lib/db/migrations.ts`:\n   ```typescript\n   import { db } from './index';\n   \n   export async function exportAllProjects() {\n     const projects = await db.getAllProjects();\n     return {\n       version: '1.0',\n       exportedAt: Date.now(),\n       projects: projects\n     };\n   }\n   \n   export async function importProjects(data: any) {\n     if (!data.projects || !Array.isArray(data.projects)) {\n       throw new Error('Invalid import data format');\n     }\n     \n     const results = [];\n     for (const project of data.projects) {\n       try {\n         const savedProject = await db.saveProject(project);\n         results.push({ success: true, project: savedProject });\n       } catch (error) {\n         results.push({ success: false, error: error.message, project });\n       }\n     }\n     \n     return results;\n   }\n   \n   // This will be expanded later when Supabase integration is added\n   ```\n\n7. Create a placeholder for future Supabase provider in `lib/db/supabaseProvider.ts`:\n   ```typescript\n   import { BaseStorageProvider } from './providers/base';\n   import type { Project } from './types';\n   \n   // This is a placeholder that will be implemented when Supabase integration is added\n   export class SupabaseProvider extends BaseStorageProvider {\n     // Implementation will go here when Supabase is integrated\n     // The interface will match LocalStorageProvider\n     \n     async getProject(id: string): Promise<Project | null> {\n       throw new Error('SupabaseProvider not implemented yet');\n     }\n     \n     async getAllProjects(): Promise<Project[]> {\n       throw new Error('SupabaseProvider not implemented yet');\n     }\n     \n     async saveProject(project: Project): Promise<Project> {\n       throw new Error('SupabaseProvider not implemented yet');\n     }\n     \n     async deleteProject(id: string): Promise<boolean> {\n       throw new Error('SupabaseProvider not implemented yet');\n     }\n     \n     async clear(): Promise<boolean> {\n       throw new Error('SupabaseProvider not implemented yet');\n     }\n   }\n   ```",
        "testStrategy": "1. **Unit Testing Storage Provider Interface**:\n   - Create a test suite for the LocalStorageProvider class\n   - Test each CRUD operation individually:\n     - Test `getProject` with existing and non-existing projects\n     - Test `saveProject` with new and updated projects\n     - Test `deleteProject` functionality\n     - Test `getAllProjects` returns correct data\n   - Test ID generation uniqueness\n   - Test clear functionality\n\n2. **Integration Testing Database API**:\n   - Create test cases for project lifecycle (create, save, retrieve, delete)\n   - Test saving and retrieving projects with video file references\n   - Test saving and retrieving projects with funscript data\n   - Verify project settings persistence\n   - Test concurrent operations and data consistency\n\n3. **Storage Limit Testing**:\n   - Test behavior when approaching localStorage limits (typically 5-10MB)\n   - Test graceful error handling when storage is full\n   - Verify appropriate error messages for storage issues\n\n4. **Data Migration Testing**:\n   - Test the export functionality to ensure all projects are properly collected\n   - Test import functionality with valid and invalid data\n   - Verify data structure is suitable for future Supabase migration\n   - Test data integrity during export/import cycles\n\n5. **Performance Testing**:\n   - Measure read/write performance with multiple projects\n   - Test performance with large funscript data\n   - Benchmark operations with projects containing video file references\n\n6. **Mock Application Integration**:\n   - Create a simple test application that uses the database layer\n   - Test real-world usage patterns (create project, save funscript, reopen project)\n   - Verify the API is intuitive and consistent for project-based workflow\n\n7. **Error Handling and Recovery**:\n   - Test behavior when localStorage is unavailable\n   - Test handling of corrupted data in localStorage\n   - Verify error messages are helpful and actionable\n   - Test recovery mechanisms for interrupted operations\n\n8. **Cross-Browser Compatibility**:\n   - Test in Chrome, Firefox, Safari, and Edge\n   - Test File System Access API availability (Chromium browsers)\n   - Verify consistent behavior across browsers\n   - Test in private/incognito mode\n\n9. **Manual Testing Checklist**:\n   - Verify all database operations through browser console\n   - Inspect localStorage contents to confirm proper data structure\n   - Test project persistence across page refreshes\n   - Test video file handle persistence in supported browsers\n   - Verify no memory leaks occur during extended usage",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Implement Data Validation and Error Handling for Database Layer",
        "description": "Add robust data validation, error handling, and migration utilities to the database abstraction layer to ensure data integrity and facilitate future transition to Supabase.",
        "details": "1. Create a validation system for all data models:\n   - Create `lib/db/validation.ts` with Zod schemas for all data types\n   - Implement validators for Project data, ensuring proper data structure\n   - Add runtime type checking with detailed error messages\n\n2. Enhance error handling in the database layer:\n   - Create `lib/db/errors.ts` with custom error classes:\n     ```typescript\n     export class DatabaseError extends Error {\n       constructor(message: string) {\n         super(`Database Error: ${message}`);\n         this.name = 'DatabaseError';\n       }\n     }\n     \n     export class ValidationError extends DatabaseError {\n       constructor(message: string, public validationErrors: any) {\n         super(`Validation Error: ${message}`);\n         this.name = 'ValidationError';\n       }\n     }\n     \n     export class StorageError extends DatabaseError {\n       constructor(message: string) {\n         super(`Storage Error: ${message}`);\n         this.name = 'StorageError';\n       }\n     }\n     ```\n   - Implement try/catch blocks in all database operations\n   - Add error logging and recovery mechanisms\n   - Create error boundary components for UI error handling\n\n3. Implement data migration utilities:\n   - Create `lib/db/migrations.ts` with version-based migration system\n   - Add schema versioning to track database structure changes\n   - Implement data transformation functions for each schema version\n   - Create migration runner that can upgrade data from any version to latest\n\n4. Add data integrity checks:\n   - Implement transaction-like operations for multi-step data changes\n   - Add data consistency validation before and after operations\n   - Create periodic integrity check utility for localStorage data\n   - Implement data repair functions for corrupted entries\n\n5. Create backup and restore functionality:\n   - Add export/import of all database data as JSON\n   - Implement automatic backup before major operations\n   - Create recovery system from backups\n   - Add backup rotation and management\n\n6. Prepare for Supabase migration:\n   - Create data mapping utilities between localStorage and Supabase formats\n   - Implement data chunking for large datasets\n   - Add offline/online synchronization logic\n   - Create migration wizard UI component",
        "testStrategy": "1. Unit Testing Validation System:\n   - Test each Zod schema with valid and invalid data\n   - Verify validation error messages are descriptive and actionable\n   - Test edge cases like empty objects, null values, and type mismatches\n   - Validate that all required fields are properly enforced\n\n2. Error Handling Tests:\n   - Create test suite that triggers each error type\n   - Verify error propagation through the application\n   - Test error recovery mechanisms\n   - Validate error logging functionality\n   - Test UI error boundaries with simulated database errors\n\n3. Migration Utility Tests:\n   - Create test datasets for each schema version\n   - Verify migration from each version to the latest\n   - Test migration of large datasets for performance\n   - Validate data integrity before and after migration\n   - Test interrupted migration scenarios and recovery\n\n4. Data Integrity Tests:\n   - Create test cases that intentionally corrupt data\n   - Verify integrity check identifies all issues\n   - Test repair functions restore data correctly\n   - Validate transaction-like operations maintain consistency\n   - Test concurrent operations handling\n\n5. Backup/Restore Testing:\n   - Test export of database to JSON file\n   - Verify import restores all data correctly\n   - Test automatic backup triggers\n   - Validate backup rotation functionality\n   - Test recovery from various backup points\n\n6. Integration Testing:\n   - Test the database layer with actual application components\n   - Verify all CRUD operations work end-to-end\n   - Test performance with large datasets\n   - Validate error handling in real-world scenarios",
        "status": "pending",
        "dependencies": [
          14
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Implement Multi-ROI Management System for Video Editing",
        "description": "Create a comprehensive system for managing multiple Regions of Interest (ROIs) throughout a video timeline with CRUD operations, visual editing, and time-based activation using a hybrid XState + Zustand architecture that leverages the strengths of both state management systems.",
        "status": "pending",
        "dependencies": [
          2,
          4,
          12,
          14
        ],
        "priority": "high",
        "details": "1. **Hybrid State Management Architecture**:\n   - **XState handles**: ROI persistence, time-based activation, project integration, complex state transitions\n   - **Zustand handles**: UI interactions, temporary states, drag operations, hover states, edit modes\n   - Clear separation of concerns with custom hooks for integration\n\n2. **Extend Existing ROI Data Models and Types**:\n   - Build upon existing ROI structure in `types/editor.ts`:\n   ```typescript\n   export interface ROI {\n     id: string; // Generated using nanoid(5) - maintain existing pattern\n     title: string;\n     x: number;\n     y: number;\n     w: number;\n     h: number;\n     startTime: number;\n     endTime: number;\n     isSelected: boolean;\n     isActive: boolean;\n   }\n   \n   export interface ROIState {\n     rois: ROI[]; // Extend existing single ROI to array\n     selectedROIId: string | null; // Build upon existing selectedROIid\n     activeROIIds: string[];\n   }\n   \n   export interface ROIUIState {\n     dragState: ROIDragState | null;\n     hoverROIId: string | null;\n     editMode: 'select' | 'create' | 'edit';\n     tempROI: Partial<ROI> | null;\n   }\n   ```\n\n3. **Extend Existing MotionMachine ROI State (XState)**:\n   - Modify existing `motionMachine.rois` array to support multiple ROIs\n   - Extend existing `selectedROIid` state to work with new multi-ROI selection\n   - Maintain backward compatibility with current XState architecture\n   - Add new ROI-specific events while preserving existing state transitions\n   - Integrate with existing project storage schema for ROI persistence\n   - Handle complex ROI lifecycle and time-based activation logic\n\n4. **Create ROI UI Store (Zustand)**:\n   - Handle temporary UI states like drag operations and hover effects\n   - Manage edit modes and temporary ROI creation states\n   - Provide fast, reactive updates for smooth user interactions\n   - Integrate with XState through custom hooks for state synchronization\n\n5. **Enhance Existing VideoROIWrapper Component**:\n   - Extend current VideoROIWrapper draggable functionality for multiple ROIs\n   - Build upon existing ROI rendering and interaction patterns\n   - Maintain compatibility with current drag-and-drop implementation\n   - Add multi-ROI selection and bulk editing capabilities\n   - Preserve existing visual feedback systems while adding new states\n   - Use hybrid state approach: XState for persistence, Zustand for interactions\n\n6. **Build Control Panel ROI Tab Using Existing Infrastructure**:\n   - Create `components/ControlPanel/ROITab.tsx` using established Shadcn/ui patterns\n   - Leverage existing Popover, AlertDialog, and form components\n   - Maintain consistency with current Control Panel design language\n   - Integrate with existing validation patterns and error handling\n   - Use established project-based workflow patterns\n   - Connect to both XState (persistence) and Zustand (UI state) stores\n\n7. **Implement Custom Integration Hooks**:\n   - Create `hooks/useROIState.ts` for unified access to both state systems\n   - Implement `hooks/useROIActions.ts` for coordinated actions across stores\n   - Provide clear patterns for future motion tracking implementation\n   - Document hybrid architecture patterns and best practices\n\n8. **Enhance Time-based Activation System (XState)**:\n   - Build upon existing video synchronization infrastructure\n   - Integrate with current video timeupdate event handling\n   - Maintain compatibility with existing frame-by-frame stepping\n   - Use established debouncing patterns for performance\n   - Leverage existing project data integration\n   - Handle complex activation logic in XState machine\n\n9. **Extend Visual Feedback System (Zustand)**:\n   - Build upon existing ROI visual states and styling\n   - Maintain current Tailwind CSS patterns and theme integration\n   - Extend existing hover effects and interaction feedback\n   - Preserve current accessibility and keyboard navigation support\n   - Add smooth transitions using established animation patterns\n   - Use Zustand for fast UI state updates during interactions",
        "testStrategy": "1. **Hybrid State Management Testing**:\n   - Test XState and Zustand integration through custom hooks\n   - Verify state synchronization between both systems\n   - Test performance of hybrid approach with large numbers of ROIs\n   - Validate clear separation of concerns between persistence and UI state\n\n2. **ROI CRUD Operations Testing (XState)**:\n   - Test creating ROIs with valid and invalid properties using existing validation patterns\n   - Verify ROI updates persist correctly in XState and storage with current project system\n   - Test delete functionality with confirmation dialog using existing Shadcn/ui patterns\n   - Validate form validation prevents invalid ROI properties with established error handling\n\n3. **Visual Editing Testing (Zustand + XState)**:\n   - Test dragging ROIs within video bounds using Zustand for smooth interactions\n   - Verify resize operations maintain existing interaction patterns with fast UI updates\n   - Test visual feedback for different ROI states building on current design system\n   - Validate ROI positioning accuracy with existing video synchronization\n   - Test state synchronization between UI interactions (Zustand) and persistence (XState)\n\n4. **Time-based Activation Testing (XState)**:\n   - Test ROI activation/deactivation with existing video playback synchronization\n   - Verify multiple overlapping ROIs activate correctly with current timing system\n   - Test edge cases using established video player integration patterns\n   - Validate performance with large numbers of ROIs using existing optimization approaches\n\n5. **Integration Testing**:\n   - Test ROI state persistence with existing project-based storage system\n   - Verify integration with current video player synchronization infrastructure\n   - Test ROI data export/import with established project system workflows\n   - Validate XState integration maintains existing functionality and state transitions\n   - Test custom hooks provide unified access to both state systems\n\n6. **Backward Compatibility Testing**:\n   - Verify existing single ROI functionality continues to work\n   - Test migration of existing projects with ROI data\n   - Validate current VideoROIWrapper interactions remain functional\n   - Test existing motionMachine state transitions with new ROI extensions\n\n7. **User Experience Testing**:\n   - Test popover editing workflow follows existing Control Panel patterns\n   - Verify keyboard navigation maintains current accessibility standards\n   - Test responsive behavior with established layout system\n   - Validate error messages follow current user feedback patterns\n   - Test smooth UI interactions powered by Zustand with XState persistence",
        "subtasks": [
          {
            "id": 1,
            "title": "Create ROI Data Models and Type Definitions",
            "description": "Extend types/editor.ts with comprehensive ROI interfaces including ROI, ROIState, ROIUIState, and related utility types with proper TypeScript definitions for hybrid state management",
            "status": "pending",
            "dependencies": [],
            "details": "Define ROI interface with id (nanoid(5)), title, x/y/w/h coordinates (0-100%), startTime/endTime, isSelected/isActive booleans. Create ROIState interface for XState with rois array, selectedROIId, and activeROIIds array. Create ROIUIState interface for Zustand with dragState, hoverROIId, editMode, and tempROI. Add utility types for ROI creation, updates, and validation. Include proper JSDoc comments for all interfaces. Define clear boundaries between persistent state (XState) and UI state (Zustand).",
            "testStrategy": "Create unit tests for type validation, interface compatibility, and utility type functions. Test ROI coordinate bounds validation and time range validation. Verify type separation between XState and Zustand interfaces."
          },
          {
            "id": 2,
            "title": "Implement ROI UI Store with Zustand for Interaction States",
            "description": "Create stores/roiUIStore.ts using Zustand for fast UI state management including drag operations, hover states, edit modes, and temporary ROI creation",
            "status": "pending",
            "dependencies": [
              1
            ],
            "details": "Implement Zustand store for UI-specific ROI state: drag operations (startDrag, updateDrag, endDrag), hover states (setHoverROI, clearHover), edit modes (setEditMode), and temporary ROI creation (setTempROI, clearTempROI). Add optimistic updates for smooth UI interactions. Include validation for drag boundaries and coordinate constraints. Implement debounced updates to prevent excessive re-renders. Design store to work seamlessly with XState through custom hooks.",
            "testStrategy": "Test all UI state operations with rapid user interactions. Verify drag state management with boundary constraints. Test hover state updates and cleanup. Validate edit mode transitions and temporary ROI handling. Test performance with frequent state updates."
          },
          {
            "id": 3,
            "title": "Extend Existing MotionMachine for Multi-ROI Support with XState",
            "description": "Modify the existing motionMachine in stores/fsEditActor.ts to extend current ROI functionality for multiple ROIs while maintaining backward compatibility, handling persistence and complex state logic",
            "status": "pending",
            "dependencies": [
              1
            ],
            "details": "Extend existing motionMachine.rois array to handle multiple ROIs instead of single ROI. Modify existing selectedROIid state to work with new selectedROIId pattern. Add new ROI-specific events (ROI_CREATED, ROI_UPDATED, ROI_DELETED, ROI_SELECTED, ROI_ACTIVATED) while preserving existing state transitions. Ensure backward compatibility with current XState architecture. Integrate multi-ROI persistence with existing project storage system. Handle complex ROI lifecycle management and time-based activation logic. Design clear integration points with Zustand UI store.",
            "testStrategy": "Test state machine transitions with new ROI events while ensuring existing functionality remains intact. Verify ROI context updates correctly with current project system. Test backward compatibility with existing single ROI projects. Validate state machine integrity with concurrent ROI and editor operations. Test integration with Zustand UI store through custom hooks."
          },
          {
            "id": 4,
            "title": "Build Time-based ROI Activation System with XState Integration",
            "description": "Create lib/roiActivation.ts with efficient logic to determine and update active ROIs based on current video playback time, integrating with XState for complex activation logic",
            "status": "pending",
            "dependencies": [
              3
            ],
            "details": "Implement activateROIsAtTime function that efficiently determines which ROIs should be active at given timestamp. Integrate with existing video timeupdate event handling from Task 7's synchronization system. Add debouncing using established patterns to prevent excessive activation updates. Implement binary search or interval tree for efficient time-based lookups when dealing with many ROIs. Leverage existing project data integration patterns. Connect with XState machine for complex activation state management and persistence. Design to work independently of Zustand UI state.",
            "testStrategy": "Test activation accuracy at various timestamps with existing video synchronization. Verify performance with large numbers of ROIs using current optimization patterns. Test edge cases like overlapping time ranges and boundary conditions. Validate debouncing prevents excessive updates while maintaining sync accuracy. Test XState integration for activation state persistence."
          },
          {
            "id": 5,
            "title": "Create Custom Integration Hooks for Hybrid State Management",
            "description": "Build hooks/useROIState.ts and hooks/useROIActions.ts to provide unified access to both XState and Zustand stores with clear integration patterns",
            "status": "pending",
            "dependencies": [
              2,
              3
            ],
            "details": "Create useROIState hook that provides unified access to both XState (persistence, activation) and Zustand (UI interactions) state. Implement useROIActions hook that coordinates actions across both stores, ensuring proper state synchronization. Add useROIDrag hook for drag operation management. Create useROISelection hook for selection state management. Include proper TypeScript types and JSDoc documentation. Design hooks to serve as the primary interface for components, abstracting the hybrid architecture complexity. Document patterns for future motion tracking implementation.",
            "testStrategy": "Test hook integration between XState and Zustand stores. Verify state synchronization through hook actions. Test hook performance with frequent updates. Validate TypeScript types and error handling. Test hooks provide consistent interface regardless of underlying state system complexity."
          },
          {
            "id": 6,
            "title": "Create Control Panel ROI Tab Interface with Hybrid State Integration",
            "description": "Build components/ControlPanel/ROITab.tsx with comprehensive CRUD interface using existing Shadcn/ui components and hybrid state management through custom hooks",
            "status": "pending",
            "dependencies": [
              5
            ],
            "details": "Create ROI list display following existing Control Panel design patterns. Implement Shadcn/ui Popover components for editing ROI properties using established form patterns. Add form validation for all ROI properties with real-time feedback following current validation approach. Include Shadcn/ui AlertDialog for delete confirmations using existing dialog patterns. Add bulk selection and operations consistent with current UI patterns. Implement search and filter functionality using established component library. Use custom hooks to access both XState (persistence) and Zustand (UI state) seamlessly.",
            "testStrategy": "Test all form validations with edge cases using existing validation patterns. Verify popover interactions and form submissions follow established UX patterns. Test delete confirmation flows with current dialog system. Validate bulk operations and filtering functionality. Test keyboard navigation and accessibility compliance with existing standards. Test integration with hybrid state management through custom hooks."
          },
          {
            "id": 7,
            "title": "Enhance Existing VideoROIWrapper for Multi-ROI Display with Hybrid State",
            "description": "Extend the existing VideoROIWrapper component to support multiple ROI visualization using hybrid state management for optimal performance and persistence",
            "status": "pending",
            "dependencies": [
              5
            ],
            "details": "Build upon existing VideoROIWrapper absolute-positioned overlay to render multiple ROI rectangles. Extend current visual states (inactive, active, selected) to support multi-ROI scenarios. Add new combined state (active+selected) while preserving existing styling patterns. Enhance existing hover effects and tooltips to work with multiple ROIs using Zustand for fast UI updates. Ensure proper z-index management maintains current video player integration. Preserve backward compatibility with existing single ROI rendering. Use custom hooks to seamlessly integrate XState (persistence, activation) and Zustand (hover, drag states).",
            "testStrategy": "Test visual rendering accuracy across different video sizes with existing responsive patterns. Verify all visual states display correctly with current styling system. Test overlay positioning with existing video player integration. Validate performance with multiple simultaneous ROIs using hybrid state approach. Test backward compatibility with existing single ROI functionality. Test smooth UI interactions powered by Zustand with XState persistence."
          },
          {
            "id": 8,
            "title": "Extend Interactive ROI Editing with Hybrid State Management",
            "description": "Enhance existing VideoROIWrapper drag-and-drop functionality to support multiple ROI editing using Zustand for smooth interactions and XState for persistence",
            "status": "pending",
            "dependencies": [
              7
            ],
            "details": "Extend existing mouse event handlers for ROI dragging and resizing to work with multiple ROIs using Zustand for immediate UI feedback. Build upon current drag handles on ROI corners and edges for resizing. Maintain existing boundary constraints (0-100%) while adding multi-ROI selection support. Enhance existing visual feedback during drag operations using fast Zustand updates. Implement real-time state synchronization between Zustand (drag state) and XState (persistence) through custom hooks. Add bulk editing capabilities while preserving individual ROI interaction patterns. Use debouncing to sync UI state changes to XState for persistence.",
            "testStrategy": "Test drag and resize operations with existing boundary enforcement for multiple ROIs. Verify real-time state synchronization between Zustand UI updates and XState persistence. Test edge cases like rapid mouse movements and boundary collisions with multiple ROIs. Validate undo/redo functionality extends to multi-ROI operations through XState. Test backward compatibility with existing single ROI editing. Test performance of hybrid state approach during intensive drag operations."
          },
          {
            "id": 9,
            "title": "Integrate Multi-ROI with Existing Project System and Document Hybrid Architecture",
            "description": "Extend existing project storage system to support multi-ROI data through XState while documenting the hybrid architecture patterns for future motion tracking implementation",
            "status": "pending",
            "dependencies": [
              3,
              8
            ],
            "details": "Extend existing project schema to support multi-ROI data structure while maintaining backward compatibility. Implement ROI array serialization/deserialization for existing project save/load operations through XState. Add multi-ROI data to current project export/import functionality. Ensure ROI state is properly restored when switching between projects using existing patterns. Implement ROI data migration for existing single ROI projects to multi-ROI format. Add multi-ROI validation to existing project validation system. Document hybrid XState + Zustand architecture patterns, integration hooks usage, and best practices for future motion tracking implementation. Create architectural decision records (ADRs) explaining state management choices.",
            "testStrategy": "Test ROI persistence across browser sessions with existing project system through XState. Verify project export/import includes multi-ROI data using current patterns. Test schema migration with existing single ROI projects. Validate multi-ROI data integrity after save/load cycles with current storage system. Test error handling for corrupted ROI data using established error patterns. Test backward compatibility with existing single ROI projects. Validate documentation completeness and accuracy for future development."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-07-18T15:50:46.311Z",
      "updated": "2025-07-29T11:12:20.586Z",
      "description": "Tasks for master context"
    }
  }
}